### 最长上升子序列变式问题

**1.P2285 [HNOI2004] 打鼹鼠**
> 问题链接：https://www.luogu.com.cn/problem/P2285

此题最难想的便是dp方程的设计。
最终都没想到这一题居然归在 **LIS问题** 里。

下面是题目：
***
### [HNOI2004] 打鼹鼠

#### 题目描述

鼹鼠是一种很喜欢挖洞的动物，但每过一定的时间，它还是喜欢把头探出到地面上来透透气的。根据这个特点阿牛编写了一个打鼹鼠的游戏：在一个 $n \times n$ 的网格中，在某些时刻鼹鼠会在某一个网格探出头来透透气。你可以控制一个机器人来打鼹鼠，如果 $i$ 时刻鼹鼠在某个网格中出现，而机器人也处于同一网格的话，那么这个鼹鼠就会被机器人打死。而机器人每一时刻只能够移动一格或停留在原地不动。机器人的移动是指从当前所处的网格移向相邻的网格，即从坐标为 $(i, j)$ 的网格移向 $(i-1, j), (i+1, j), (i, j-1), (i, j+1)$ 四个网格，机器人不能走出整个 $n \times n$ 的网格。游戏开始时，你可以自由选定机器人的初始位置。

现在知道在一段时间内，鼹鼠出现的时间和地点，请编写一个程序使机器人在这一段时间内打死尽可能多的鼹鼠。

#### 输入格式

第一行为 $n, m$（$n \le 1000$，$m \le {10}^4$），其中 $m$ 表示在这一段时间内出现的鼹鼠的个数，接下来的 $m$ 行中每行有三个数据 $\mathit{time}, x, y$ 表示在游戏开始后 $\mathit{time}$ 个时刻，在第 $x$ 行第 $y$ 个网格里出现了一只鼹鼠。$\mathit{time}$ 按递增的顺序给出。注意同一时刻可能出现多只鼹鼠，但同一时刻同一地点只可能出现一只鼹鼠。

#### 输出格式

仅包含一个正整数，表示被打死鼹鼠的最大数目。

#### 样例 #1

##### 样例输入 #1

```
2 2	         
1 1 1		
2 2 2
```

##### 样例输出 #1

```
1
```
***
如何理解这一题呢。一开始打算想设计的是 **DFS搜索+记忆化** 但最终发现时间之间的冲突非常不好处理。
这里首先用到了一个重要思想，一个初中就已经学过的思想：
$$
\Delta x=v\times \Delta t
$$
位移等于速度乘以时间。首先我们给出的时间，是绝对递增的。走一格花一秒，说明 $v = 1\;m/s$，而题目给出了所有的时间刻，因此我们完全可以计算出：**到达下一个点的 曼哈顿距离 等于 时间差**

所以我们从一开始就可以判断当前点能不能到达下一个指定的点，只需要曼哈顿距离小于等于时间差就可以了。

然后我们考虑，把这个问题转化一下。空间中有若干个点，找出最长的序列，序列中的所有点，相邻两两之间时间差大于等于其曼哈顿距离。

至于为什么是小于等于呢？
考虑所有时间刻的鼹鼠都出现在同一个点即可。时间差为n，但曼哈顿距离为0。或者中间时间隔得很久，但两点距离非常近。那我们可以一直原地不动，到对应时间差以后再移动到那个位置即可。

我们可以把这些所有的点按照时间顺序放在一起。
$arr=\{1,2,3,3,4,5,6,7,7\}$
而**对应坐标作为这些点的附加属性**。

例如：1 可以到 3，3 可以再到 7。那么就有一条路线：1 -> 3 -> 7。

这其实就是一个特殊条件下的 **LIS**。

只不过从原来求解 **最长递增子序列** 变成了 **最长时间差大于等于曼哈顿距离的子序列**

我们在 LIS 代码上稍作改进即可：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxN = 1e4+5;
int arr[maxN], x[maxN], y[maxN], dp[maxN];

int dis(int x1, int y1, int x2, int y2) {
    return abs(x1-x2)+abs(y1-y2);
}

int main()
{   
    int n{}, m{};
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        cin >> arr[i] >> x[i] >> y[i];
    }

    int ans{};
    for (int i = 1; i <= m; i++)
    {
        dp[i] = 1;  //注意初始化
        for (int j = 1; j < i; j++)
        {
            if (dis(x[i],y[i],x[j],y[j]) <= arr[i]-arr[j]) {
                dp[i] = max(dp[i],dp[j]+1);
            }
        }
        ans = max(ans,dp[i]);
    }
    
    cout << ans << endl;

    system("pause");
    return 0;
}
```
