# 琪露诺

## 题目描述

在幻想乡，琪露诺是以笨蛋闻名的冰之妖精。

某一天，琪露诺又在玩速冻青蛙，就是用冰把青蛙瞬间冻起来。但是这只青蛙比以往的要聪明许多，在琪露诺来之前就已经跑到了河的对岸。于是琪露诺决定到河岸去追青蛙。

小河可以看作一列格子依次编号为 $0$ 到 $N$，琪露诺只能从编号小的格子移动到编号大的格子。而且琪露诺按照一种特殊的方式进行移动，当她在格子 $i$ 时，她只移动到区间 $[i+L,i+R]$ 中的任意一格。你问为什么她这么移动，这还不简单，因为她是笨蛋啊。

每一个格子都有一个冰冻指数 $A_i$，编号为 $0$ 的格子冰冻指数为 $0$。当琪露诺停留在那一格时就可以得到那一格的冰冻指数 $A_i$。琪露诺希望能够在到达对岸时，获取最大的冰冻指数，这样她才能狠狠地教训那只青蛙。

但是由于她实在是太笨了，所以她决定拜托你帮它决定怎样前进。

开始时，琪露诺在编号 $0$ 的格子上，只要她下一步的位置编号大于 $N$ 就算到达对岸。

## 输入格式

第一行三个正整数 $N, L, R$。

第二行共 $N+1$ 个整数，第 $i$ 个数表示编号为 $i-1$ 的格子的冰冻指数 $A_{i-1}$。

## 输出格式

一个整数，表示最大冰冻指数。

## 样例 #1

### 样例输入 #1

```
5 2 3
0 12 3 11 7 -2
```

### 样例输出 #1

```
11
```

## 提示

对于 $60\%$ 的数据，$N \le 10^4$。

对于 $100\%$ 的数据，$N \le 2\times 10^5$，$-10^3 \le  A_i\le 10^3 $，$1 \le L \le R \le N $。数据保证最终答案不超过 $2^{31}-1$。
****
我们考虑这道问题：
如果题目并非给出区间 $[L,R]$ 而只是简单给出一个值 $x$，那么我们再思考这题怎么做？

那么这题就简单了。
$dp[i] = dp[i-x]+arr[i]$

我们给出代码：
```cpp
for(int i = x; i <= n; i++)//从x开始,前面的格子跳不到
{
	dp[i] = dp[i-x] + arr[i];
	if(i + x > n) //判断下一步是否直接跳到岸上
		ans = max(dp[i], ans);//记录最优答案
}
```
但现在我们给出的是区间，那么我们也只需要把状态转移方程改变一下就好了：
$dp[i] = \max\limits_{k=0}^{r-l}{(dp[i-r+k])}+arr[i]$

我们也给出代码：
```cpp
for(int i = l; i <= n; i++)
{
	for (int k = 0; k <= r-l; k++) {
		//注意去除不能跳跃的点
		if (i >= r-k && dp[i-r+k] != val) {
			dp[i] = max(dp[i], dp[i-r+k] + arr[i]);
		}
	}

	if(i + r > n) 
		ans = max(dp[i], ans);
}
```

但这样，我们的答案是会超时的，只能拿到 **80** 分。
如何优化呢？

我回去看刚刚的式子：
$dp[i] = \max\limits_{k=0}^{r-l}{(dp[i-r+k])}+arr[i]$

我们发现，$\max\limits_{k=0}^{r-l}{(dp[i-r+k])}$ 它的含义为：**求一个定长区间的最大值**

嗯？定长区间的最大值？
> $1\;-2\;\;\;3\;\;\;[\;4\;\;\;\;5\;\;-3\;]\;\;\;4\;\;\;5$

这不就是 **滑动窗口求最大值** 吗？
既然如此，那么就可以 **单调队列优化** 写起来了。
我们按照滑动窗口求最大值的方法，来获取这里的区间最大值就好了。
```cpp
deque<int> que;
for(int i = l; i <= n; i++)
{
	if (i >= l) {
		while (!que.empty() && dp[i-l] > dp[que.back()]) que.pop_back();
		que.emplace_back(i-l);

		if (!que.empty() && que.front() < i-r) que.pop_front();
	}

	dp[i] = dp[que.front()] + arr[i];

	if(i + r > n) 
		ans = max(dp[i], ans);
}
```
****

<center><b>-------------------<题目分割线>-------------------</b></center>

****
# 大师

## 题目背景

建筑大师最近在跟着数学大师 ljt12138 学数学，今天他学了等差数列，ljt12138 决定给他留一道练习题。

## 题目描述

ljt12138 首先建了 $n$ 个特斯拉电磁塔，这些电塔排成一排，从左到右依次标号为 $1$ 到 $n$，第 $i$ 个电塔的高度为 $h[i]$。

建筑大师需要从中选出一些电塔，然后这些电塔就会缩到地下去。这时候，如果留在地上的电塔的高度，从左向右构成了一个等差数列，那么这个选择方案就会被认为是美观的。

建筑大师需要求出，一共有多少种美观的选择方案，答案模 $998244353$。

注意，如果地上只留了一个或者两个电塔，那么这种方案也是美观的。地上没有电塔的方案被认为是不美观的。

同时也要注意，等差数列的公差也可以为负数。

## 输入格式

第一行一个正整数 $n$。

第二行 $n$ 个非负整数，第 $i$ 个整数是第 $i$ 个电塔的高度 $h[i]$。

## 输出格式

输出一个整数，表示美观的方案数模 $998244353$ 的值。

## 样例 #1

### 样例输入 #1

```
8
13 14 6 20 27 34 34 41
```

### 样例输出 #1

```
50
```

## 样例 #2

### 样例输入 #2

```
100
90 1004 171 99 1835 108 81 117 141 126 135 144 81 153 193 81 962 162 1493 171 1780 864 297 180 532 1781 189 1059 198 333 1593 824 207 1877 216 270 225 1131 336 1875 362 234 81 288 1550 243 463 1755 252 406 261 270 279 288 1393 261 1263 297 135 333 872 234 881 180 198 81 225 306 180 90 315 81 81 198 252 81 297 1336 1140 1238 81 198 297 661 81 1372 469 1132 81 126 324 333 342 81 351 481 279 1770 1225 549
```

### 样例输出 #2

```
11153
```

## 提示

设 $v$ 为最高的电塔高度。

对于前 $30\%$ 的数据，$n \le 20 $。

对于前 $60\%$ 的数据，$n \le 100$，$v \le 2 \times 10^3$。

对于另外 $20\%$ 的数据，所有电塔的高度构成一个等差数列。

对于 $100\%$ 的数据，$n \le 10^3$，$v \leq2 \times 10^4$。
***
先反思一波，线性DP 最需要的真就是思考。
根据输入格式，这是一个 **单串线性DP**，根据状态数，这是 **二维线性DP**。这里发现有两个状态很重要，首先根据单串线性DP的常见做法，很快想到一个状态是 **以i为结尾的等差数列数量**。但由于不同等差数列的公差不同，这样我们的第二个状态为 **公差**。

那么总而言之先设计出 $dp[i][j]$，表示 **以i结尾，公差为j的等差数列数量**。

同时注意到题目存在方向性，也就是只能从左到右。我们第一步已经完成了：**设计dp数组**

接下来考虑 **如何设计状态转移方程**。

> 约定 $h[i]$ 是题目给出高度序列。
> 
> 假设当前求的是 $dp[i][j]$，由于选择的等差数列元素可以间断（即不要求为一个连续区间），那么仿照 LIS 的做法。我们从 $[1,i]$ 取前面的序列进行状态转移。
>
> 那么现在有 $dp[k][j]（1 \leq k \leq i）$，显然如果 $dp[k][j]$ 如果有 $a$ 个等差数列。
> 那么 $dp[i][j]$ 就是在前面所有的等差数列的基础上再加上当前元素，继承 $dp[k][j]$ 的值。
>
> 因此 $dp[i][j] += dp[k][j]$ 即可。
> 我们如何找到 公差 $j$ 呢？
> 这其实很简单：$j=h[i]-h[k]$，为了防止出现负数公差，我们整体右移 $v$ 即可。$j=h[i]-h[k]+v$

现在我们已经完成了，dp数组设计，状态转移方程。最后考虑的是 **初始化**。

对于这一整个序列，由于单个元素，和两个元素在此题中都能算一个"等差数列"。那么所有元素一开始本身都是长度为 1 的数列，因此我们初始化 dp数组 所有元素为 1。

但要注意一点，我们转移的时候，是从大于一长度的等差数列开始存储答案的，所以我们需要额外再加上单个元素的等差数列。
```cpp
fill(dp[0],dp[0]+maxN*(2*v+1),1);
for (int i = 1; i <= n; i++)
{
	ans++;
	for (int j = 1; j < i; j++)
	{
		dp[i][h[i]-h[j]+v] += (dp[j][h[i]-h[j]+v]) % md;
		dp[i][h[i]-h[j]+v] %= md;
		ans += (dp[j][h[i]-h[j]+v]) % md;
		ans %= md;  //注意取模运算
	}
}
```

如果不考虑 dp数组 初始化为 1 呢？
实际上也是可以的，不过我们在进行状态转移的时候，就需要额外加上只有两个元素组成的等差数列这一情况：
```cpp
for (int i = 1; i <= n; i++)
{
	ans++;
	for (int j = 1; j < i; j++)
	{
		dp[i][h[i]-h[j]+v] += (dp[j][h[i]-h[j]+v] + 1) % md;
		dp[i][h[i]-h[j]+v] %= md;
		ans += (dp[j][h[i]-h[j]+v] + 1) % md;
		ans %= md;  //注意取模运算
	}
}
```
****

<center><b>-------------------<题目分割线>-------------------</b></center>

****
# 快速求和

## 题目背景

2023-10-08 update: 新增两组 hack。

2023-12-16 update: 新增两组 hack。

## 题目描述

给定一个数字字符串，用最小次数的加法让字符串等于一个给定的目标数字。每次加法就是在字符串的某个位置插入一个加号。在里面要的所有加号都插入后，就像做普通加法那样来求值。

例如，考虑字符串`12`，做 $0$ 次加法，我们得到数字 $12$。如果插入 $1$ 个加号，我们得到 $3$，因此，这个例子中，最少用 $1$ 次加法就得到数字 $3$。

再举一例，考虑字符串`303`和目标数字 $6$，最佳方法不是`3+0+3`。而是`3+03`。能这样做是因为一个数的前导 $0$ 不会改变它的大小。

## 输入格式

第一行：一个字符串 $s$。

第二行：一个整数 $n$。

## 输出格式

一行一个整数表示最少的加法次数让 $s$ 等于 $n$。如果怎么做都不能让 $s$ 等于 $n$ ，则输出 $-1$。

## 样例 #1

### 样例输入 #1

```
99999
45
```

### 样例输出 #1

```
4
```

## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le \operatorname{len}(s)\le40$，$1 \leq n\le10^5$。
***
这题...这题...啊啊啊啊啊啊！
一开始的思路是完全正确的，现在来精确总结一下方程是怎么得出来的：

**1. 分析**
首先从样例入手，发现我们要dp的样例为单串输入。
马上设计一个：
$dp[i]$ 表示 $[0,i]$ 的最小加和次数，且和为 $n$。

然后思考，这个方程怎么转移：
> 嗯..和为 $n$，$dp[i]$ = ... ?
> 等于什么？通常前 $i$ 个的分割和应该不能达到 $n$ 的吧。

于是发现，这样设计是很难推进下去的。
我们下意识设计 $dp[i]$ 为 $[0,i]$ 上的状态转移，是因为 **单串动态规划** 的大部分情况都是这样设计的。
但现在我们遇到了难以推导方程的情况，这说明我们的 **状态** 少了。

很快能想到一件事，既然等于不了 $n$，我假设等于 $s$ 呢？

设计：$dp[i][s]$ 表示 $[0,i]$ 的最小加和次数，且和为 $s$。

现在来设计一下状态转移方程看看：
1. **第一直觉**
$dp[i][s] = dp[i-1][s-arr[i]] + 1$
既然要求 $[0,i]$ 加和为 $s$，那么我们先找到 $[0,i-1]$ 加和为 $s-arr[i]$ 的不就好了吗？这样的话加上当前的 $arr[i]$ 不就刚好满足我们要的情况了！

2. **二次思考**
但我们再仔细想想，我们插入加号的位置是任意的，非得是 $[0,i-1]$ 吗？有没有情况再更往前的时候存在更少的加号使用数，但是因为当前加和的数字大所以也可以满足情况呢？
$dp[i][s] = \min\limits_{k\leq i}\{dp[k-1][s-arr[i]]\} + 1$

3. **查漏补缺**
看起来似乎是万无一失了，等等。题目的添上加号，类似把一个数组进行分割求和，并不是取数字！因此我们把 $k$ 向前移的时候，我们所要加的数字已经不只是 $arr[i]$ 了。而是 $num[k][i]$ ! $num[left][right]$ 表示数字字符串 $[left,right]$ 截取下来的那一部分数字，很显然，就有：
$dp[i][s] = \min\limits_{1\leq k\leq i}\{dp[k-1][s-num[k][i]]\} + 1$

心想，这下总万无一失了吧！
已经非常完美了！
是的，的确已经很完美了，不过在编码上还有一些注意事项：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long

const ll maxN = 1e5+5;
ll sum[45][45], n;
ll dp[45][maxN];

int main(int argc, char const *argv[])
{
    string num{};
    cin >> num >> n;

    fill(dp[0],dp[0]+45*maxN,INT_MAX);	//由于求的是最小值，那么我们一开始要初始化成最大值

    ll len = num.size();
    for (ll i = 1; i <= len; i++)
    {
        for (ll j = i; j <= len; j++)
        {
            sum[i][j] = sum[i][j-1] * 10 + (num[j-1]-'0');
            if (i == 1 && sum[i][j] <= n && sum[i][j] >= 0) dp[j][sum[i][j]] = 0; //注意初始化，即那些区间本身就是要求给定数字的，不需要添加加号，为 0
        }
    }
    
    //dp[0][0] = -1; 可以这样初始化，非常简易，下面的 k >= 2 改成 k >= 1
    for (ll i = 1; i <= len; i++)
    {
        for (ll j = 0; j <= n; j++)
        {
            for (ll k = i; k >= 1; k--)
            { //从后往前算，这是因为越往前分割，sum[k][i] 分出来的数字也就越大，要是超过了 n ，我们就直接跳过，进行一个剪枝
                if (sum[k][i] > n) break;
                if (j >= sum[k][i] && k >= 2) 
                    dp[i][j] = min(dp[i][j],dp[k-1][j-sum[k][i]]+1);
            }
        }
    }
    
    cout << ((dp[len][n] <= len-1) ? dp[len][n] : -1) << endl;
    
    system("pause");
    return 0;
}
```
****

<center><b>-------------------<题目分割线>-------------------</b></center>

****
# 编辑距离

## 题目描述

设 $A$ 和 $B$ 是两个字符串。我们要用最少的字符操作次数，将字符串 $A$ 转换为字符串 $B$。这里所说的字符操作共有三种：

1. 删除一个字符；
2. 插入一个字符；
3. 将一个字符改为另一个字符。

$A, B$ 均只包含小写字母。

## 输入格式

第一行为字符串 $A$；第二行为字符串 $B$；字符串 $A, B$ 的长度均小于 $2000$。

## 输出格式

只有一个正整数，为最少字符操作次数。

## 样例 #1

### 样例输入 #1

```
sfdqxbw
gfdgw
```

### 样例输出 #1

```
4
```

## 提示

对于 $100 \%$ 的数据，$1 \le |A|, |B| \le 2000$。
****
这题是线性动态规划的经典题之一