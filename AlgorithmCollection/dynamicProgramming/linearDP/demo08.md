## [P2679 [NOIP2015 提高组] 子串](https://www.luogu.com.cn/problem/P2679)

有些话想说，这一题，我希望可以就此突破我的线性DP，最近越来越感觉松懈了。可能是各方面状态不够好。
包括文化课也好，真的不知道下学期能学的有多好。(此时大一上学期)，又是算法，又是文化课。回想起自己的各种梦想，当初的保证。真的感觉看视频很有愧疚感。但还是浪费了很多时间，现在想来，如果用来健身，估计都瘦了不少了。现在又是眼睛痛，又是注意力不集中。

明明需要花更多时间去做别的题目，我还把时间浪费在这个上面，目前还是想着突破吧。真的已经浪费我很多时间了，但既然如此我就要理解透这个题目的本质，希望我可以明白动态规划的精髓在哪里。

**这样才对得起自己，对得起小灿，对得起我的承诺。**

(先运动1小时去缓解一下眼睛疲劳)

------------------

先来说说动态规划，它底层的原理的是什么，我们有很多的理解方面：
1. 子结构问题
2. 无后效性
3. 递推
4. 记忆化搜索
5. 减少重复计算量

那么，我们如何根据这些性质，来做动态规划题。
一个动态规划题目一般有三个关键步骤：
**1. 寻找 $dp$ 数组**
**2. 找出递推方程**
**3. 初始化**

咱们一个一个步骤来讲。
对于第一个：
1. 找出 $dp$ 数组
   对于这个问题，就靠经验。我们首先要判断这个题目能不能用dp，有几个方面：数据范围，是否存在无后效性质的子结构，是经典dp问题。<br>
   确定可以使用dp解题以后，我们观察输入数据，是单串，还是双串。如果确定是线性DP，那么为了保证无后效性质，我们一般把dp数组确定为 `到i为止` 或者 `第i位之前` 或者 `以第i位结尾`。这样才有我们递推的份。其次，单串双串决定了最基本的dp维数，例如双串，就是二维dp，即`dp[i][j]`。<br>
   有些问题，它可以转化成dp来做。例如当一个问题可以转化为求解"最长递增子序列"的时候，我们自然可以套用LIS的标准模板。<br>
   单串，双串，是一项指标。但dp数组的维数，还有另外的决定因素。要找出题目中的种种相关变量，甚至隐含变量，例如需要分出不同情况，也就是说**树存在一个新分支**，那么我们就需要多开一个维度，来区分这种情况。我们需要保证情况是完美的。
<br>

2. 找出递推方程
   这个时候才是考验你的知识的时候：
   1. 条件
   2. 递推关系
   3. 分类讨论

   这实际上是很难的一件事。要仔细仔细读懂题意，并且需要富有想象力。想象那些情况，有些情况很简单，有些很难。
<br>
3. 初始化
   这一步其实是最轻松的，只需要找出递推方程中的那个$a_1$就够了。实在不行，就直接特判。

--------------------------------------
现在，我们再来仔细说说这个题目。
我们先要学会一个假设。
字符串，拆分，匹配。又加上是子序列问题，很快可以联想到dp。
由于题目是双串，并且存在k情况变量。因此我们先开出三维。

$dp[i][j][k]$ 表示 **"$A$ 最后一个字符匹配到了 $i$，并且拼出了长度为前 $j$ 的 $B$，同时我们在 $A$ 中分了 $k$ 段"。**

我们来看看，怎么个转移法。

$$
\mathrm{If~A_i=B_j} \\
dp[i][j][k] = dp[i-1][j-1][k-1]
$$

对吗？我们很快会爆出一堆问题。
首先就是，这个分段选，中间可隔开，可不隔。也可以连续选一段，也可以是单个字符。

首先，可选可不选，这个属于一种新情况，我们要明确一点，由于dp是无后效性的，也就是我们前面选了还是没选，只负责进行状态递推的那一步，对再一步不存在干扰，相当于情况已经整合进去了。
那么我们添加一个新的维度 **[1/0]** 表示这一位选了，还是不选。

而至于，连续，还是单独字符的问题。是由 $k$ 来决定的，
如果递推的时候我们从 $k-1$ 转移，那么显然我们肯定是取了一个单独字符。如果从 $k$ 转移，那么看来我们直接将当前的这个字符合并进去了，不影响分割数，那么：
现在再来推导递推方程，就非常简单了。

$$
\mathrm{If~A_i = B_j} \\
dp[i][j][k][0] = dp[i-1][j][k][1] + dp[i-1][j][k][0]; \\
dp[i][j][k][1] = dp[i-1][j-1][k][1] + dp[i-1][j-1][k-1][1] + dp[i-1][j-1][k-1][0]; \\
\;\\
\mathrm{If~A_i \not ={B_i}} \\
dp[i][j][k][0] = dp[i-1][j][k][1] + dp[i-1][j][k][0]; \\
dp[i][j][k][1] = 0;
$$

最后我们再来想想初始条件：
$dp[1][0][0][0] = dp[0][0][0][0] = 1$